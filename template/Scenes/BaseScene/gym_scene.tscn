[gd_scene load_steps=36 format=3 uid="uid://yv0trygv2sj6"]

[ext_resource type="Script" uid="uid://c1w13jal8gato" path="res://Scripts/Scene Management/scene_base_multi_viewport.gd" id="1_7v7fq"]
[ext_resource type="Script" uid="uid://cnp2oeiooqh77" path="res://Scripts/Viewports/world_viewport.gd" id="2_haok2"]
[ext_resource type="Script" uid="uid://5bngowlite7i" path="res://Scripts/Scene Management/world_origin.gd" id="3_haok2"]
[ext_resource type="Shader" uid="uid://c3utm4uwysvgs" path="res://Scripts/Resources/Materials/Master Materials/Shaders/master_outline_f+_shader.gdshader" id="4_jen3y"]
[ext_resource type="Shader" uid="uid://dnxd40vb1mm5c" path="res://Scripts/Resources/Materials/Master Materials/Shaders/master_toon_f+_shader.gdshader" id="5_l31wr"]
[ext_resource type="Texture2D" uid="uid://d3kegs5gff16p" path="res://Assets/Textures/texture_16px 1.png" id="6_l31wr"]
[ext_resource type="Texture2D" uid="uid://dmnmxjfgm2tig" path="res://Assets/Textures/texture_16px 143.png" id="7_3on8w"]
[ext_resource type="Texture2D" uid="uid://bxmx5dbv7so0p" path="res://Assets/Textures/texture_16px 98.png" id="8_tafei"]
[ext_resource type="Texture2D" uid="uid://wyku74sxbrvm" path="res://Assets/Textures/texture_16px 41.png" id="9_gbjtv"]
[ext_resource type="Script" uid="uid://dcug3eyqlc57d" path="res://Scripts/Basic3D/rotator_3d.gd" id="10_lqpt3"]
[ext_resource type="Script" uid="uid://bwmv0h8vt8jwr" path="res://test_omni_light.gd" id="11_p0ovr"]
[ext_resource type="PackedScene" uid="uid://droxnvqcx5vy4" path="res://Scenes/Particles/torch_flame_particle.tscn" id="12_pswpk"]

[sub_resource type="ShaderMaterial" id="ShaderMaterial_4jfj4"]
render_priority = 0
shader = ExtResource("4_jen3y")
shader_parameter/shadows_enabled = true
shader_parameter/highlights_enabled = true
shader_parameter/shadow_strength = 0.4
shader_parameter/highlight_strength = 0.1
shader_parameter/highlight_color = Color(1, 1, 1, 1)
shader_parameter/shadow_color = Color(0, 0, 0, 1)

[sub_resource type="ShaderMaterial" id="ShaderMaterial_3on8w"]
render_priority = 0
next_pass = SubResource("ShaderMaterial_4jfj4")
shader = ExtResource("5_l31wr")
shader_parameter/albedo = Color(1, 1, 1, 1)
shader_parameter/clamp_diffuse_to_max = false
shader_parameter/cuts = 4
shader_parameter/wrap = 0.0
shader_parameter/steepness = 1.0
shader_parameter/use_attenuation = true
shader_parameter/use_specular = false
shader_parameter/specular_strength = 1.0
shader_parameter/specular_shininess = 16.0
shader_parameter/use_rim = false
shader_parameter/rim_width = 8.0
shader_parameter/rim_color = Color(1, 1, 1, 1)
shader_parameter/use_ramp = false
shader_parameter/use_borders = false
shader_parameter/border_width = 0.01

[sub_resource type="PlaneMesh" id="PlaneMesh_haok2"]
material = SubResource("ShaderMaterial_3on8w")

[sub_resource type="Environment" id="Environment_haok2"]
background_mode = 1
background_color = Color(0.53625923, 0.4735239, 0.46453434, 1)
ambient_light_color = Color(0.6977309, 0.82641405, 0.8697117, 1)
reflected_light_source = 1
ssil_enabled = true

[sub_resource type="ShaderMaterial" id="ShaderMaterial_tafei"]
render_priority = 0
next_pass = SubResource("ShaderMaterial_4jfj4")
shader = ExtResource("5_l31wr")
shader_parameter/albedo = Color(1, 1, 1, 1)
shader_parameter/albedo_texture = ExtResource("6_l31wr")
shader_parameter/clamp_diffuse_to_max = false
shader_parameter/cuts = 4
shader_parameter/wrap = 0.0
shader_parameter/steepness = 2.0000000475
shader_parameter/use_attenuation = true
shader_parameter/use_specular = false
shader_parameter/specular_strength = 1.0
shader_parameter/specular_shininess = 16.0
shader_parameter/use_rim = false
shader_parameter/rim_width = 8.0
shader_parameter/rim_color = Color(1, 1, 1, 1)
shader_parameter/use_ramp = false
shader_parameter/use_borders = false
shader_parameter/border_width = 0.01

[sub_resource type="BoxMesh" id="BoxMesh_gbjtv"]
material = SubResource("ShaderMaterial_tafei")
size = Vector3(0.1, 0.1, 0.1)

[sub_resource type="Shader" id="Shader_tafei"]
code = "shader_type spatial;
render_mode unshaded;

// MIT License. Made by Leo Peltola
// Inspired by https://threejs.org/examples/webgl_postprocessing_pixel.html

uniform sampler2D DEPTH_TEXTURE : hint_depth_texture, filter_linear_mipmap;
uniform sampler2D SCREEN_TEXTURE : hint_screen_texture, filter_linear_mipmap;
uniform sampler2D NORMAL_TEXTURE : hint_normal_roughness_texture, filter_nearest;

uniform bool shadows_enabled = true;
uniform bool highlights_enabled = true;
uniform float shadow_strength : hint_range(0.0, 1.0, 0.01) = 0.4;
uniform float highlight_strength : hint_range(0.0, 1.0, 0.01) = 0.1;
uniform vec3 highlight_color : source_color = vec3(1.);
uniform vec3 shadow_color : source_color = vec3(0.0);

varying mat4 model_view_matrix;


float getDepth(vec2 screen_uv, sampler2D depth_texture, mat4 inv_projection_matrix){
//	Credit: https://godotshaders.com/shader/depth-modulated-pixel-outline-in-screen-space/
	float raw_depth = texture(depth_texture, screen_uv)[0];
	vec3 normalized_device_coordinates = vec3(screen_uv * 2.0 - 1.0, raw_depth);
    vec4 view_space = inv_projection_matrix * vec4(normalized_device_coordinates, 1.0);	
	view_space.xyz /= view_space.w;	
	return -view_space.z;
}

vec3 getPos(float depth, mat4 mvm, mat4 ipm, vec2 suv, mat4 wm, mat4 icm){
  vec4 pos = inverse(mvm) * ipm * vec4((suv * 2.0 - 1.0), depth * 2.0 - 1.0, 1.0);
  pos.xyz /= (pos.w+0.0001*(1.-abs(sign(pos.w))));
  return (pos*icm).xyz+wm[3].xyz;
}

float normalIndicator(vec3 normalEdgeBias, vec3 baseNormal, vec3 newNormal, float depth_diff){
	// Credit: https://threejs.org/examples/webgl_postprocessing_pixel.html
	float normalDiff = dot(baseNormal - newNormal, normalEdgeBias);
	float normalIndicator = clamp(smoothstep(-.01, .01, normalDiff), 0.0, 1.0);
	float depthIndicator = clamp(sign(depth_diff * .25 + .0025), 0.0, 1.0);
	return (1.0 - dot(baseNormal, newNormal)) * depthIndicator * normalIndicator;
}

void vertex(){
    model_view_matrix = VIEW_MATRIX * mat4(INV_VIEW_MATRIX[0], INV_VIEW_MATRIX[1], INV_VIEW_MATRIX[2], MODEL_MATRIX[3]);
}

void fragment() {
	vec2 e = vec2(1./VIEWPORT_SIZE.xy);
	
//	Shadows
	float depth_diff = 0.0;
	float neg_depth_diff = .5;
	if (shadows_enabled) {
		float depth = getDepth(SCREEN_UV, DEPTH_TEXTURE, INV_PROJECTION_MATRIX);
		float du = getDepth(SCREEN_UV+vec2(0., -1.)*e, DEPTH_TEXTURE, INV_PROJECTION_MATRIX);
		float dr = getDepth(SCREEN_UV+vec2(1., 0.)*e, DEPTH_TEXTURE, INV_PROJECTION_MATRIX);
		float dd = getDepth(SCREEN_UV+vec2(0., 1.)*e, DEPTH_TEXTURE, INV_PROJECTION_MATRIX);
		float dl = getDepth(SCREEN_UV+vec2(-1., 0.)*e, DEPTH_TEXTURE, INV_PROJECTION_MATRIX);
		depth_diff += clamp(du - depth, 0., 1.);
		depth_diff += clamp(dd - depth, 0., 1.);
		depth_diff += clamp(dr - depth, 0., 1.);
		depth_diff += clamp(dl - depth, 0., 1.);
		neg_depth_diff += depth - du;
		neg_depth_diff += depth - dd;
		neg_depth_diff += depth - dr;
		neg_depth_diff += depth - dl;
		neg_depth_diff = clamp(neg_depth_diff, 0., 1.);
		neg_depth_diff = clamp(smoothstep(0.5, 0.5, neg_depth_diff)*10., 0., 1.);
		depth_diff = smoothstep(0.2, 0.3, depth_diff);
//		ALBEDO = vec3(neg_depth_diff);
	}
	
//	Highlights
	float normal_diff = 0.;
	if (highlights_enabled) {
		vec3 normal = texture(NORMAL_TEXTURE, SCREEN_UV).rgb * 2.0 - 1.0;
		vec3 nu = texture(NORMAL_TEXTURE, SCREEN_UV+vec2(0., -1.)*e).rgb * 2.0 - 1.0;
		vec3 nr = texture(NORMAL_TEXTURE, SCREEN_UV+vec2(1., 0.)*e).rgb * 2.0 - 1.0;
		vec3 nd = texture(NORMAL_TEXTURE, SCREEN_UV+vec2(0., 1.)*e).rgb * 2.0 - 1.0;
		vec3 nl = texture(NORMAL_TEXTURE, SCREEN_UV+vec2(-1., 0.)*e).rgb * 2.0 - 1.0;
		vec3 normal_edge_bias = (vec3(1., 1., 1.));
		normal_diff += normalIndicator(normal_edge_bias, normal, nu, depth_diff);
		normal_diff += normalIndicator(normal_edge_bias, normal, nr, depth_diff);
		normal_diff += normalIndicator(normal_edge_bias, normal, nd, depth_diff);
		normal_diff += normalIndicator(normal_edge_bias, normal, nl, depth_diff);
		normal_diff = smoothstep(0.2, 0.8, normal_diff);
		normal_diff = clamp(normal_diff-neg_depth_diff, 0., 1.);
//		ALBEDO = vec3(normal_diff);
	}
	

	vec3 original_color = texture(SCREEN_TEXTURE, SCREEN_UV).rgb;
	vec3 final_highlight_color = mix(original_color, highlight_color, highlight_strength);
	vec3 final_shadow_color = mix(original_color, shadow_color, shadow_strength);
	vec3 final = original_color;
	if (highlights_enabled) {
		final = mix(final, final_highlight_color, normal_diff);
	}
	if (shadows_enabled) {
		final = mix(final, final_shadow_color, depth_diff);
	}
	ALBEDO = final;

	float alpha_mask = depth_diff * float(shadows_enabled) + normal_diff * float(highlights_enabled);
	ALPHA = clamp((alpha_mask) * 5., 0., 1.);
}"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_gbjtv"]
render_priority = 0
shader = SubResource("Shader_tafei")
shader_parameter/shadows_enabled = true
shader_parameter/highlights_enabled = true
shader_parameter/shadow_strength = 0.4
shader_parameter/highlight_strength = 0.1
shader_parameter/highlight_color = Color(1, 1, 1, 1)
shader_parameter/shadow_color = Color(0, 0, 0, 1)

[sub_resource type="Shader" id="Shader_lqpt3"]
code = "shader_type spatial;

//render_mode ambient_light_disabled;

uniform vec4 albedo : source_color = vec4(1.0f);
uniform sampler2D albedo_texture : hint_default_white,filter_nearest;
uniform bool clamp_diffuse_to_max = false;

uniform int cuts : hint_range(1, 8) = 3;
uniform float wrap : hint_range(-2.0f, 2.0f) = 0.0f;
uniform float steepness : hint_range(1.0f, 8.0f) = 1.0f;

uniform bool use_attenuation = true;

uniform bool use_specular = true;
uniform float specular_strength : hint_range(0.0f, 1.0f) = 1.0f;
uniform float specular_shininess : hint_range(0.0f, 32.0f) = 16.0f;
uniform sampler2D specular_map : hint_default_white,filter_nearest;

uniform bool use_rim = true;
uniform float rim_width : hint_range(0.0f, 16.0f) = 8.0f;
uniform vec4 rim_color : source_color = vec4(1.0f);

uniform bool use_ramp = false;
uniform sampler2D ramp : hint_default_white;

uniform bool use_borders = false;
uniform float border_width = 0.01f;

varying vec3 vertex_pos;
varying vec3 normal;

float split_specular(float specular) {
	return step(0.5f, specular);
}

void vertex() {
	vertex_pos = VERTEX;
	normal = NORMAL;
}

void fragment() {
	ALBEDO = albedo.rgb * texture(albedo_texture, UV).rgb;
}

void light() {
	// Attenuation.
	float attenuation = 1.0f;
	if (use_attenuation) {
		attenuation = ATTENUATION;
	}
	
	// Diffuse lighting.
	float NdotL = dot(NORMAL, LIGHT);
	float diffuse_amount = NdotL + (attenuation - 1.0) + wrap;
	//float diffuse_amount = NdotL * attenuation + wrap;
	diffuse_amount *= steepness;
	float cuts_inv = 1.0f / float(cuts);
	float diffuse_stepped = clamp(diffuse_amount + mod(1.0f - diffuse_amount, cuts_inv), 0.0f, 1.0f);

	// Calculate borders.
	float border = 0.0f;
	if (use_borders) {
		float corr_border_width = length(cross(NORMAL, LIGHT)) * border_width * steepness;
		border = step(diffuse_stepped - corr_border_width, diffuse_amount)
				 - step(1.0 - corr_border_width, diffuse_amount);
	}
	
	// Apply diffuse result to different styles.
	vec3 diffuse = ALBEDO.rgb * LIGHT_COLOR / PI;
	if (use_ramp) {
		diffuse *= texture(ramp, vec2(diffuse_stepped * (1.0f - border), 0.0f)).rgb;
	} else {
		diffuse *= diffuse_stepped * (1.0f - border);
	}
	
	if (clamp_diffuse_to_max) {
		// Clamp diffuse to max for multiple light sources.
		DIFFUSE_LIGHT = max(DIFFUSE_LIGHT, diffuse);
	} else {
		DIFFUSE_LIGHT += diffuse;
	}
	
	// Specular lighting.
	if (use_specular) {
		vec3 H = normalize(LIGHT + VIEW);
		float NdotH = dot(NORMAL, H);
		float specular_amount = max(pow(NdotH, specular_shininess*specular_shininess), 0.0f)
							    * texture(specular_map, UV).r
								* attenuation;
		specular_amount = split_specular(specular_amount);
		SPECULAR_LIGHT += specular_strength * specular_amount * LIGHT_COLOR;
	}
	
	// Simple rim lighting.
	if (use_rim) {
		float NdotV = dot(NORMAL, VIEW);
		float rim_light = pow(1.0 - NdotV, rim_width);
		DIFFUSE_LIGHT += rim_light * rim_color.rgb * rim_color.a * LIGHT_COLOR / PI;
	}
}"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_p0ovr"]
render_priority = 0
next_pass = SubResource("ShaderMaterial_gbjtv")
shader = SubResource("Shader_lqpt3")
shader_parameter/albedo = Color(1, 1, 1, 1)
shader_parameter/albedo_texture = ExtResource("7_3on8w")
shader_parameter/clamp_diffuse_to_max = false
shader_parameter/cuts = 4
shader_parameter/wrap = 0.0
shader_parameter/steepness = 1.0
shader_parameter/use_attenuation = true
shader_parameter/use_specular = false
shader_parameter/specular_strength = 1.0
shader_parameter/specular_shininess = 16.0
shader_parameter/use_rim = false
shader_parameter/rim_width = 8.0
shader_parameter/rim_color = Color(1, 1, 1, 1)
shader_parameter/use_ramp = false
shader_parameter/use_borders = false
shader_parameter/border_width = 0.01

[sub_resource type="SphereMesh" id="SphereMesh_pswpk"]
material = SubResource("ShaderMaterial_p0ovr")
radius = 0.063
height = 0.125
radial_segments = 16
rings = 8

[sub_resource type="Shader" id="Shader_gbjtv"]
code = "shader_type spatial;
render_mode unshaded;

// MIT License. Made by Leo Peltola
// Inspired by https://threejs.org/examples/webgl_postprocessing_pixel.html

uniform sampler2D DEPTH_TEXTURE : hint_depth_texture, filter_linear_mipmap;
uniform sampler2D SCREEN_TEXTURE : hint_screen_texture, filter_linear_mipmap;
uniform sampler2D NORMAL_TEXTURE : hint_normal_roughness_texture, filter_nearest;

uniform bool shadows_enabled = true;
uniform bool highlights_enabled = true;
uniform float shadow_strength : hint_range(0.0, 1.0, 0.01) = 0.4;
uniform float highlight_strength : hint_range(0.0, 1.0, 0.01) = 0.1;
uniform vec3 highlight_color : source_color = vec3(1.);
uniform vec3 shadow_color : source_color = vec3(0.0);

varying mat4 model_view_matrix;


float getDepth(vec2 screen_uv, sampler2D depth_texture, mat4 inv_projection_matrix){
//	Credit: https://godotshaders.com/shader/depth-modulated-pixel-outline-in-screen-space/
	float raw_depth = texture(depth_texture, screen_uv)[0];
	vec3 normalized_device_coordinates = vec3(screen_uv * 2.0 - 1.0, raw_depth);
    vec4 view_space = inv_projection_matrix * vec4(normalized_device_coordinates, 1.0);	
	view_space.xyz /= view_space.w;	
	return -view_space.z;
}

vec3 getPos(float depth, mat4 mvm, mat4 ipm, vec2 suv, mat4 wm, mat4 icm){
  vec4 pos = inverse(mvm) * ipm * vec4((suv * 2.0 - 1.0), depth * 2.0 - 1.0, 1.0);
  pos.xyz /= (pos.w+0.0001*(1.-abs(sign(pos.w))));
  return (pos*icm).xyz+wm[3].xyz;
}

float normalIndicator(vec3 normalEdgeBias, vec3 baseNormal, vec3 newNormal, float depth_diff){
	// Credit: https://threejs.org/examples/webgl_postprocessing_pixel.html
	float normalDiff = dot(baseNormal - newNormal, normalEdgeBias);
	float normalIndicator = clamp(smoothstep(-.01, .01, normalDiff), 0.0, 1.0);
	float depthIndicator = clamp(sign(depth_diff * .25 + .0025), 0.0, 1.0);
	return (1.0 - dot(baseNormal, newNormal)) * depthIndicator * normalIndicator;
}

void vertex(){
    model_view_matrix = VIEW_MATRIX * mat4(INV_VIEW_MATRIX[0], INV_VIEW_MATRIX[1], INV_VIEW_MATRIX[2], MODEL_MATRIX[3]);
}

void fragment() {
	vec2 e = vec2(1./VIEWPORT_SIZE.xy);
	
//	Shadows
	float depth_diff = 0.0;
	float neg_depth_diff = .5;
	if (shadows_enabled) {
		float depth = getDepth(SCREEN_UV, DEPTH_TEXTURE, INV_PROJECTION_MATRIX);
		float du = getDepth(SCREEN_UV+vec2(0., -1.)*e, DEPTH_TEXTURE, INV_PROJECTION_MATRIX);
		float dr = getDepth(SCREEN_UV+vec2(1., 0.)*e, DEPTH_TEXTURE, INV_PROJECTION_MATRIX);
		float dd = getDepth(SCREEN_UV+vec2(0., 1.)*e, DEPTH_TEXTURE, INV_PROJECTION_MATRIX);
		float dl = getDepth(SCREEN_UV+vec2(-1., 0.)*e, DEPTH_TEXTURE, INV_PROJECTION_MATRIX);
		depth_diff += clamp(du - depth, 0., 1.);
		depth_diff += clamp(dd - depth, 0., 1.);
		depth_diff += clamp(dr - depth, 0., 1.);
		depth_diff += clamp(dl - depth, 0., 1.);
		neg_depth_diff += depth - du;
		neg_depth_diff += depth - dd;
		neg_depth_diff += depth - dr;
		neg_depth_diff += depth - dl;
		neg_depth_diff = clamp(neg_depth_diff, 0., 1.);
		neg_depth_diff = clamp(smoothstep(0.5, 0.5, neg_depth_diff)*10., 0., 1.);
		depth_diff = smoothstep(0.2, 0.3, depth_diff);
//		ALBEDO = vec3(neg_depth_diff);
	}
	
//	Highlights
	float normal_diff = 0.;
	if (highlights_enabled) {
		vec3 normal = texture(NORMAL_TEXTURE, SCREEN_UV).rgb * 2.0 - 1.0;
		vec3 nu = texture(NORMAL_TEXTURE, SCREEN_UV+vec2(0., -1.)*e).rgb * 2.0 - 1.0;
		vec3 nr = texture(NORMAL_TEXTURE, SCREEN_UV+vec2(1., 0.)*e).rgb * 2.0 - 1.0;
		vec3 nd = texture(NORMAL_TEXTURE, SCREEN_UV+vec2(0., 1.)*e).rgb * 2.0 - 1.0;
		vec3 nl = texture(NORMAL_TEXTURE, SCREEN_UV+vec2(-1., 0.)*e).rgb * 2.0 - 1.0;
		vec3 normal_edge_bias = (vec3(1., 1., 1.));
		normal_diff += normalIndicator(normal_edge_bias, normal, nu, depth_diff);
		normal_diff += normalIndicator(normal_edge_bias, normal, nr, depth_diff);
		normal_diff += normalIndicator(normal_edge_bias, normal, nd, depth_diff);
		normal_diff += normalIndicator(normal_edge_bias, normal, nl, depth_diff);
		normal_diff = smoothstep(0.2, 0.8, normal_diff);
		normal_diff = clamp(normal_diff-neg_depth_diff, 0., 1.);
//		ALBEDO = vec3(normal_diff);
	}
	

	vec3 original_color = texture(SCREEN_TEXTURE, SCREEN_UV).rgb;
	vec3 final_highlight_color = mix(original_color, highlight_color, highlight_strength);
	vec3 final_shadow_color = mix(original_color, shadow_color, shadow_strength);
	vec3 final = original_color;
	if (highlights_enabled) {
		final = mix(final, final_highlight_color, normal_diff);
	}
	if (shadows_enabled) {
		final = mix(final, final_shadow_color, depth_diff);
	}
	ALBEDO = final;

	float alpha_mask = depth_diff * float(shadows_enabled) + normal_diff * float(highlights_enabled);
	ALPHA = clamp((alpha_mask) * 5., 0., 1.);
}"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_lqpt3"]
render_priority = 0
shader = SubResource("Shader_gbjtv")
shader_parameter/shadows_enabled = true
shader_parameter/highlights_enabled = true
shader_parameter/shadow_strength = 0.4
shader_parameter/highlight_strength = 0.1
shader_parameter/highlight_color = Color(1, 1, 1, 1)
shader_parameter/shadow_color = Color(0, 0, 0, 1)

[sub_resource type="Shader" id="Shader_p0ovr"]
code = "shader_type spatial;

//render_mode ambient_light_disabled;

uniform vec4 albedo : source_color = vec4(1.0f);
uniform sampler2D albedo_texture : hint_default_white,filter_nearest;
uniform bool clamp_diffuse_to_max = false;

uniform int cuts : hint_range(1, 8) = 3;
uniform float wrap : hint_range(-2.0f, 2.0f) = 0.0f;
uniform float steepness : hint_range(1.0f, 8.0f) = 1.0f;

uniform bool use_attenuation = true;

uniform bool use_specular = true;
uniform float specular_strength : hint_range(0.0f, 1.0f) = 1.0f;
uniform float specular_shininess : hint_range(0.0f, 32.0f) = 16.0f;
uniform sampler2D specular_map : hint_default_white,filter_nearest;

uniform bool use_rim = true;
uniform float rim_width : hint_range(0.0f, 16.0f) = 8.0f;
uniform vec4 rim_color : source_color = vec4(1.0f);

uniform bool use_ramp = false;
uniform sampler2D ramp : hint_default_white;

uniform bool use_borders = false;
uniform float border_width = 0.01f;

varying vec3 vertex_pos;
varying vec3 normal;

float split_specular(float specular) {
	return step(0.5f, specular);
}

void vertex() {
	vertex_pos = VERTEX;
	normal = NORMAL;
}

void fragment() {
	ALBEDO = albedo.rgb * texture(albedo_texture, UV).rgb;
}

void light() {
	// Attenuation.
	float attenuation = 1.0f;
	if (use_attenuation) {
		attenuation = ATTENUATION;
	}
	
	// Diffuse lighting.
	float NdotL = dot(NORMAL, LIGHT);
	float diffuse_amount = NdotL + (attenuation - 1.0) + wrap;
	//float diffuse_amount = NdotL * attenuation + wrap;
	diffuse_amount *= steepness;
	float cuts_inv = 1.0f / float(cuts);
	float diffuse_stepped = clamp(diffuse_amount + mod(1.0f - diffuse_amount, cuts_inv), 0.0f, 1.0f);

	// Calculate borders.
	float border = 0.0f;
	if (use_borders) {
		float corr_border_width = length(cross(NORMAL, LIGHT)) * border_width * steepness;
		border = step(diffuse_stepped - corr_border_width, diffuse_amount)
				 - step(1.0 - corr_border_width, diffuse_amount);
	}
	
	// Apply diffuse result to different styles.
	vec3 diffuse = ALBEDO.rgb * LIGHT_COLOR / PI;
	if (use_ramp) {
		diffuse *= texture(ramp, vec2(diffuse_stepped * (1.0f - border), 0.0f)).rgb;
	} else {
		diffuse *= diffuse_stepped * (1.0f - border);
	}
	
	if (clamp_diffuse_to_max) {
		// Clamp diffuse to max for multiple light sources.
		DIFFUSE_LIGHT = max(DIFFUSE_LIGHT, diffuse);
	} else {
		DIFFUSE_LIGHT += diffuse;
	}
	
	// Specular lighting.
	if (use_specular) {
		vec3 H = normalize(LIGHT + VIEW);
		float NdotH = dot(NORMAL, H);
		float specular_amount = max(pow(NdotH, specular_shininess*specular_shininess), 0.0f)
							    * texture(specular_map, UV).r
								* attenuation;
		specular_amount = split_specular(specular_amount);
		SPECULAR_LIGHT += specular_strength * specular_amount * LIGHT_COLOR;
	}
	
	// Simple rim lighting.
	if (use_rim) {
		float NdotV = dot(NORMAL, VIEW);
		float rim_light = pow(1.0 - NdotV, rim_width);
		DIFFUSE_LIGHT += rim_light * rim_color.rgb * rim_color.a * LIGHT_COLOR / PI;
	}
}"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_pswpk"]
render_priority = 0
next_pass = SubResource("ShaderMaterial_lqpt3")
shader = SubResource("Shader_p0ovr")
shader_parameter/albedo = Color(1, 1, 1, 1)
shader_parameter/albedo_texture = ExtResource("8_tafei")
shader_parameter/clamp_diffuse_to_max = false
shader_parameter/cuts = 4
shader_parameter/wrap = 0.0
shader_parameter/steepness = 2.0000000475
shader_parameter/use_attenuation = true
shader_parameter/use_specular = false
shader_parameter/specular_strength = 1.0
shader_parameter/specular_shininess = 16.0
shader_parameter/use_rim = false
shader_parameter/rim_width = 8.0
shader_parameter/rim_color = Color(1, 1, 1, 1)
shader_parameter/use_ramp = false
shader_parameter/use_borders = false
shader_parameter/border_width = 0.01

[sub_resource type="TorusMesh" id="TorusMesh_nff20"]
material = SubResource("ShaderMaterial_pswpk")
inner_radius = 0.063
outer_radius = 0.125

[sub_resource type="Shader" id="Shader_pswpk"]
code = "shader_type spatial;
render_mode unshaded;

// MIT License. Made by Leo Peltola
// Inspired by https://threejs.org/examples/webgl_postprocessing_pixel.html

uniform sampler2D DEPTH_TEXTURE : hint_depth_texture, filter_linear_mipmap;
uniform sampler2D SCREEN_TEXTURE : hint_screen_texture, filter_linear_mipmap;
uniform sampler2D NORMAL_TEXTURE : hint_normal_roughness_texture, filter_nearest;

uniform bool shadows_enabled = true;
uniform bool highlights_enabled = true;
uniform float shadow_strength : hint_range(0.0, 1.0, 0.01) = 0.4;
uniform float highlight_strength : hint_range(0.0, 1.0, 0.01) = 0.1;
uniform vec3 highlight_color : source_color = vec3(1.);
uniform vec3 shadow_color : source_color = vec3(0.0);

varying mat4 model_view_matrix;


float getDepth(vec2 screen_uv, sampler2D depth_texture, mat4 inv_projection_matrix){
//	Credit: https://godotshaders.com/shader/depth-modulated-pixel-outline-in-screen-space/
	float raw_depth = texture(depth_texture, screen_uv)[0];
	vec3 normalized_device_coordinates = vec3(screen_uv * 2.0 - 1.0, raw_depth);
    vec4 view_space = inv_projection_matrix * vec4(normalized_device_coordinates, 1.0);	
	view_space.xyz /= view_space.w;	
	return -view_space.z;
}

vec3 getPos(float depth, mat4 mvm, mat4 ipm, vec2 suv, mat4 wm, mat4 icm){
  vec4 pos = inverse(mvm) * ipm * vec4((suv * 2.0 - 1.0), depth * 2.0 - 1.0, 1.0);
  pos.xyz /= (pos.w+0.0001*(1.-abs(sign(pos.w))));
  return (pos*icm).xyz+wm[3].xyz;
}

float normalIndicator(vec3 normalEdgeBias, vec3 baseNormal, vec3 newNormal, float depth_diff){
	// Credit: https://threejs.org/examples/webgl_postprocessing_pixel.html
	float normalDiff = dot(baseNormal - newNormal, normalEdgeBias);
	float normalIndicator = clamp(smoothstep(-.01, .01, normalDiff), 0.0, 1.0);
	float depthIndicator = clamp(sign(depth_diff * .25 + .0025), 0.0, 1.0);
	return (1.0 - dot(baseNormal, newNormal)) * depthIndicator * normalIndicator;
}

void vertex(){
    model_view_matrix = VIEW_MATRIX * mat4(INV_VIEW_MATRIX[0], INV_VIEW_MATRIX[1], INV_VIEW_MATRIX[2], MODEL_MATRIX[3]);
}

void fragment() {
	vec2 e = vec2(1./VIEWPORT_SIZE.xy);
	
//	Shadows
	float depth_diff = 0.0;
	float neg_depth_diff = .5;
	if (shadows_enabled) {
		float depth = getDepth(SCREEN_UV, DEPTH_TEXTURE, INV_PROJECTION_MATRIX);
		float du = getDepth(SCREEN_UV+vec2(0., -1.)*e, DEPTH_TEXTURE, INV_PROJECTION_MATRIX);
		float dr = getDepth(SCREEN_UV+vec2(1., 0.)*e, DEPTH_TEXTURE, INV_PROJECTION_MATRIX);
		float dd = getDepth(SCREEN_UV+vec2(0., 1.)*e, DEPTH_TEXTURE, INV_PROJECTION_MATRIX);
		float dl = getDepth(SCREEN_UV+vec2(-1., 0.)*e, DEPTH_TEXTURE, INV_PROJECTION_MATRIX);
		depth_diff += clamp(du - depth, 0., 1.);
		depth_diff += clamp(dd - depth, 0., 1.);
		depth_diff += clamp(dr - depth, 0., 1.);
		depth_diff += clamp(dl - depth, 0., 1.);
		neg_depth_diff += depth - du;
		neg_depth_diff += depth - dd;
		neg_depth_diff += depth - dr;
		neg_depth_diff += depth - dl;
		neg_depth_diff = clamp(neg_depth_diff, 0., 1.);
		neg_depth_diff = clamp(smoothstep(0.5, 0.5, neg_depth_diff)*10., 0., 1.);
		depth_diff = smoothstep(0.2, 0.3, depth_diff);
//		ALBEDO = vec3(neg_depth_diff);
	}
	
//	Highlights
	float normal_diff = 0.;
	if (highlights_enabled) {
		vec3 normal = texture(NORMAL_TEXTURE, SCREEN_UV).rgb * 2.0 - 1.0;
		vec3 nu = texture(NORMAL_TEXTURE, SCREEN_UV+vec2(0., -1.)*e).rgb * 2.0 - 1.0;
		vec3 nr = texture(NORMAL_TEXTURE, SCREEN_UV+vec2(1., 0.)*e).rgb * 2.0 - 1.0;
		vec3 nd = texture(NORMAL_TEXTURE, SCREEN_UV+vec2(0., 1.)*e).rgb * 2.0 - 1.0;
		vec3 nl = texture(NORMAL_TEXTURE, SCREEN_UV+vec2(-1., 0.)*e).rgb * 2.0 - 1.0;
		vec3 normal_edge_bias = (vec3(1., 1., 1.));
		normal_diff += normalIndicator(normal_edge_bias, normal, nu, depth_diff);
		normal_diff += normalIndicator(normal_edge_bias, normal, nr, depth_diff);
		normal_diff += normalIndicator(normal_edge_bias, normal, nd, depth_diff);
		normal_diff += normalIndicator(normal_edge_bias, normal, nl, depth_diff);
		normal_diff = smoothstep(0.2, 0.8, normal_diff);
		normal_diff = clamp(normal_diff-neg_depth_diff, 0., 1.);
//		ALBEDO = vec3(normal_diff);
	}
	

	vec3 original_color = texture(SCREEN_TEXTURE, SCREEN_UV).rgb;
	vec3 final_highlight_color = mix(original_color, highlight_color, highlight_strength);
	vec3 final_shadow_color = mix(original_color, shadow_color, shadow_strength);
	vec3 final = original_color;
	if (highlights_enabled) {
		final = mix(final, final_highlight_color, normal_diff);
	}
	if (shadows_enabled) {
		final = mix(final, final_shadow_color, depth_diff);
	}
	ALBEDO = final;

	float alpha_mask = depth_diff * float(shadows_enabled) + normal_diff * float(highlights_enabled);
	ALPHA = clamp((alpha_mask) * 5., 0., 1.);
}"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_nff20"]
render_priority = 0
shader = SubResource("Shader_pswpk")
shader_parameter/shadows_enabled = true
shader_parameter/highlights_enabled = true
shader_parameter/shadow_strength = 0.4
shader_parameter/highlight_strength = 0.0499999988824
shader_parameter/highlight_color = Color(1, 1, 1, 1)
shader_parameter/shadow_color = Color(0, 0, 0, 1)

[sub_resource type="Shader" id="Shader_ass8t"]
code = "shader_type spatial;

//render_mode ambient_light_disabled;

uniform vec4 albedo : source_color = vec4(1.0f);
uniform sampler2D albedo_texture : hint_default_white,filter_nearest;
uniform bool clamp_diffuse_to_max = false;

uniform int cuts : hint_range(1, 8) = 3;
uniform float wrap : hint_range(-2.0f, 2.0f) = 0.0f;
uniform float steepness : hint_range(1.0f, 8.0f) = 1.0f;

uniform bool use_attenuation = true;

uniform bool use_specular = true;
uniform float specular_strength : hint_range(0.0f, 1.0f) = 1.0f;
uniform float specular_shininess : hint_range(0.0f, 32.0f) = 16.0f;
uniform sampler2D specular_map : hint_default_white,filter_nearest;

uniform bool use_rim = true;
uniform float rim_width : hint_range(0.0f, 16.0f) = 8.0f;
uniform vec4 rim_color : source_color = vec4(1.0f);

uniform bool use_ramp = false;
uniform sampler2D ramp : hint_default_white;

uniform bool use_borders = false;
uniform float border_width = 0.01f;

varying vec3 vertex_pos;
varying vec3 normal;

float split_specular(float specular) {
	return step(0.5f, specular);
}

void vertex() {
	vertex_pos = VERTEX;
	normal = NORMAL;
}

void fragment() {
	ALBEDO = albedo.rgb * texture(albedo_texture, UV).rgb;
}

void light() {
	// Attenuation.
	float attenuation = 1.0f;
	if (use_attenuation) {
		attenuation = ATTENUATION;
	}
	
	// Diffuse lighting.
	float NdotL = dot(NORMAL, LIGHT);
	float diffuse_amount = NdotL + (attenuation - 1.0) + wrap;
	//float diffuse_amount = NdotL * attenuation + wrap;
	diffuse_amount *= steepness;
	float cuts_inv = 1.0f / float(cuts);
	float diffuse_stepped = clamp(diffuse_amount + mod(1.0f - diffuse_amount, cuts_inv), 0.0f, 1.0f);

	// Calculate borders.
	float border = 0.0f;
	if (use_borders) {
		float corr_border_width = length(cross(NORMAL, LIGHT)) * border_width * steepness;
		border = step(diffuse_stepped - corr_border_width, diffuse_amount)
				 - step(1.0 - corr_border_width, diffuse_amount);
	}
	
	// Apply diffuse result to different styles.
	vec3 diffuse = ALBEDO.rgb * LIGHT_COLOR / PI;
	if (use_ramp) {
		diffuse *= texture(ramp, vec2(diffuse_stepped * (1.0f - border), 0.0f)).rgb;
	} else {
		diffuse *= diffuse_stepped * (1.0f - border);
	}
	
	if (clamp_diffuse_to_max) {
		// Clamp diffuse to max for multiple light sources.
		DIFFUSE_LIGHT = max(DIFFUSE_LIGHT, diffuse);
	} else {
		DIFFUSE_LIGHT += diffuse;
	}
	
	// Specular lighting.
	if (use_specular) {
		vec3 H = normalize(LIGHT + VIEW);
		float NdotH = dot(NORMAL, H);
		float specular_amount = max(pow(NdotH, specular_shininess*specular_shininess), 0.0f)
							    * texture(specular_map, UV).r
								* attenuation;
		specular_amount = split_specular(specular_amount);
		SPECULAR_LIGHT += specular_strength * specular_amount * LIGHT_COLOR;
	}
	
	// Simple rim lighting.
	if (use_rim) {
		float NdotV = dot(NORMAL, VIEW);
		float rim_light = pow(1.0 - NdotV, rim_width);
		DIFFUSE_LIGHT += rim_light * rim_color.rgb * rim_color.a * LIGHT_COLOR / PI;
	}
}"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_igdx6"]
render_priority = 0
next_pass = SubResource("ShaderMaterial_nff20")
shader = SubResource("Shader_ass8t")
shader_parameter/albedo = Color(1, 1, 1, 1)
shader_parameter/albedo_texture = ExtResource("9_gbjtv")
shader_parameter/clamp_diffuse_to_max = false
shader_parameter/cuts = 4
shader_parameter/wrap = 0.0
shader_parameter/steepness = 2.0000000475
shader_parameter/use_attenuation = true
shader_parameter/use_specular = false
shader_parameter/specular_strength = 1.0
shader_parameter/specular_shininess = 16.0
shader_parameter/use_rim = false
shader_parameter/rim_width = 8.0
shader_parameter/rim_color = Color(1, 1, 1, 1)
shader_parameter/use_ramp = false
shader_parameter/use_borders = false
shader_parameter/border_width = 0.01

[sub_resource type="CylinderMesh" id="CylinderMesh_gs3ax"]
material = SubResource("ShaderMaterial_igdx6")
top_radius = 0.063
bottom_radius = 0.063
height = 0.125
radial_segments = 16
rings = 1

[sub_resource type="Gradient" id="Gradient_p0ovr"]
interpolation_mode = 2
colors = PackedColorArray(0, 0, 1, 1, 1, 0, 0, 1)

[sub_resource type="Curve" id="Curve_p0ovr"]
_data = [Vector2(0, 0), 0.0, 0.0, 0, 0, Vector2(0.20000002, 0), 1.1131228, 1.1131228, 0, 0, Vector2(0.35, 0), -1.1856663, -1.1856663, 0, 0, Vector2(0.5, 0.5), 3.3333333, 3.333334, 1, 1, Vector2(0.65, 1), 0.0, 0.0, 0, 0, Vector2(0.7985916, 1), 1.2500452, 1.2500452, 0, 0, Vector2(1, 0.9933977), -0.08844578, 0.0, 0, 0]
point_count = 7

[node name="Scene Base Multi-Viewport" type="Node"]
script = ExtResource("1_7v7fq")

[node name="Viewport Main" type="SubViewportContainer" parent="."]
offset_right = 1920.0
offset_bottom = 1080.0
stretch = true
stretch_shrink = 4

[node name="Main Viewport" type="SubViewport" parent="Viewport Main"]
handle_input_locally = false
size = Vector2i(480, 270)
render_target_update_mode = 4
script = ExtResource("2_haok2")
metadata/_custom_type_script = "uid://cnp2oeiooqh77"

[node name="WorldOrigin" type="Node3D" parent="Viewport Main/Main Viewport"]
script = ExtResource("3_haok2")

[node name="MeshInstance3D" type="MeshInstance3D" parent="Viewport Main/Main Viewport/WorldOrigin"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -0.0026547909, -0.000567019, 0)
mesh = SubResource("PlaneMesh_haok2")

[node name="SpotLight3D" type="SpotLight3D" parent="Viewport Main/Main Viewport/WorldOrigin"]
transform = Transform3D(1, 0, 0, 0, -4.3711385e-08, 0.99999994, 0, -0.99999994, -4.3711385e-08, 0, 1.6598655, 0)
light_color = Color(1, 1, 0.8980392, 1)
light_energy = 0.1
light_size = 0.03
shadow_enabled = true
spot_range = 1.825
spot_attenuation = -5.14
spot_angle = 20.0
spot_angle_attenuation = 0.116629675

[node name="WorldEnvironment" type="WorldEnvironment" parent="Viewport Main/Main Viewport/WorldOrigin"]
environment = SubResource("Environment_haok2")

[node name="Cube" type="MeshInstance3D" parent="Viewport Main/Main Viewport/WorldOrigin"]
transform = Transform3D(0.87212056, 0, 0.4892911, 0, 1, 0, -0.4892911, 0, 0.87212056, 0, 0.04969781, 0)
mesh = SubResource("BoxMesh_gbjtv")

[node name="DirectionalLight3D" type="DirectionalLight3D" parent="Viewport Main/Main Viewport/WorldOrigin"]
transform = Transform3D(0.7071068, 0.5, -0.5, 0, 0.7071068, 0.70710677, 0.7071068, -0.5, 0.5, 0, 3.000424, 0)
light_color = Color(0.7019608, 0.8156863, 1, 1)
light_energy = 0.145
shadow_enabled = true
directional_shadow_mode = 0

[node name="Sphere" type="MeshInstance3D" parent="Viewport Main/Main Viewport/WorldOrigin"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0.12842196, 0.057603635, 0.08572611)
mesh = SubResource("SphereMesh_pswpk")

[node name="Donut" type="MeshInstance3D" parent="Viewport Main/Main Viewport/WorldOrigin"]
transform = Transform3D(0.26964247, -0.4467497, -0.8530578, -0.05254507, 0.8777242, -0.4762764, 0.96152586, 0.17324832, 0.2131972, -0.15719241, 0.078247935, 0)
mesh = SubResource("TorusMesh_nff20")

[node name="Cylinder" type="MeshInstance3D" parent="Viewport Main/Main Viewport/WorldOrigin"]
transform = Transform3D(-3.9844664e-08, -0.9115397, -0.4112121, 1, -4.371139e-08, 0, -1.7974651e-08, -0.4112121, 0.9115397, 0.12975767, 0.060507864, -0.07311779)
mesh = SubResource("CylinderMesh_gs3ax")

[node name="Node3D" type="Node3D" parent="Viewport Main/Main Viewport/WorldOrigin"]
script = ExtResource("10_lqpt3")
rotation_angle = Vector3(0, 1, 0)
rotation_speed = 0.1

[node name="Camera3D" type="Camera3D" parent="Viewport Main/Main Viewport/WorldOrigin/Node3D"]
transform = Transform3D(1, 0, 0, 0, 0.89955777, 0.4368018, 0, -0.4368018, 0.89955777, 0, 1.2095842, 2.3467972)
projection = 1
current = true

[node name="Node3D2" type="Node3D" parent="Viewport Main/Main Viewport/WorldOrigin"]
script = ExtResource("10_lqpt3")
rotation_angle = Vector3(0, -1, 0)
rotation_speed = 0.25

[node name="OmniLight3D" type="OmniLight3D" parent="Viewport Main/Main Viewport/WorldOrigin/Node3D2"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0.15420857, 0.2202952, -0.055309027)
light_color = Color(0.2220834, 0.0368396, 0.16254614, 1)
light_energy = 2.0036018
shadow_enabled = true
shadow_bias = 0.072
omni_range = 0.40475503
omni_attenuation = 0.3142652
script = ExtResource("11_p0ovr")
light_hot_cold = SubResource("Gradient_p0ovr")
easing_line = SubResource("Curve_p0ovr")
range_varience = 0.01
attenuation_varience = 0.03
energy_varience = 0.01
flicker_speed = 0.5

[node name="TorchFlameParticle3D" parent="Viewport Main/Main Viewport/WorldOrigin" instance=ExtResource("12_pswpk")]
transform = Transform3D(0.1, 0, 0, 0, 0.1, 0, 0, 0, 0.1, 0.23564863, 0.0016234219, -0.4569807)

[node name="Secondary Viewport" type="SubViewportContainer" parent="."]
offset_right = 1920.0
offset_bottom = 1080.0

[node name="Secondary Viewport" type="SubViewport" parent="Secondary Viewport"]
own_world_3d = true
transparent_bg = true
handle_input_locally = false
render_target_update_mode = 4
